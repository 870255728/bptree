# 并发删除流程图

## 概述
本文档描述了B+树并发删除操作的执行流程，展示了多个线程同时进行删除操作时的同步机制和步骤。

## 流程图

```mermaid
sequenceDiagram
    participant T1 as 线程1
    participant T2 as 线程2
    participant T3 as 线程3
    participant BPT as BPlusTree
    participant BPM as BufferPoolManager
    participant DM as DiskManager
    
    Note over T1,T3: 并发删除操作开始
    
    par 线程1删除操作
        T1->>BPT: Remove(key1, &transaction)
        Note over T1,BPT: 获取全局写锁 (std::lock_guard)
        alt 树为空
            T1-->>T1: 直接返回，无操作
        else 树不为空
            T1->>BPT: Find_Leaf_Guard(key1)
            T1->>BPM: FetchPageGuard(leaf_page_id)
            T1->>BPT: 在叶子节点删除数据
            alt 删除成功
                T1->>BPT: 标记页面为脏
                alt 叶子节点下溢
                    T1->>BPT: Handle_Underflow(leaf_guard)
                    T1->>BPT: 尝试从兄弟节点借用
                    alt 借用成功
                        T1->>BPT: 更新父节点键值
                    else 借用失败
                        T1->>BPT: 合并节点
                        T1->>BPM: DeletePage(merged_page_id)
                        T1->>BPT: 更新父节点
                    end
                end
            else 删除失败
                T1-->>T1: 返回，键不存在
            end
        end
        Note over T1,BPT: 释放全局写锁
        T1-->>T1: 删除操作完成
    and 线程2删除操作
        T2->>BPT: Remove(key2, &transaction)
        Note over T2,BPT: 等待全局写锁
        Note over T2,BPT: 获取全局写锁 (std::lock_guard)
        T2->>BPT: Find_Leaf_Guard(key2)
        T2->>BPM: FetchPageGuard(leaf_page_id)
        T2->>BPT: 在叶子节点删除数据
        Note over T2,BPT: 释放全局写锁
        T2-->>T2: 删除操作完成
    and 线程3删除操作
        T3->>BPT: Remove(key3, &transaction)
        Note over T3,BPT: 等待全局写锁
        Note over T3,BPT: 获取全局写锁 (std::lock_guard)
        T3->>BPT: Find_Leaf_Guard(key3)
        T3->>BPM: FetchPageGuard(leaf_page_id)
        T3->>BPT: 在叶子节点删除数据
        Note over T3,BPT: 释放全局写锁
        T3-->>T3: 删除操作完成
    end
    
    Note over T1,T3: 所有删除操作完成
```

## 关键同步机制

### 1. 全局写锁
- 使用 `std::shared_mutex root_latch_` 作为全局写锁
- 所有删除操作都需要获取独占锁 `std::lock_guard<std::shared_mutex>`
- 确保同一时间只有一个线程可以修改树结构

### 2. 页面管理
- 使用 `PageGuard` 进行自动页面管理
- 删除操作后自动标记页面为脏状态
- 页面在作用域结束时自动释放

### 3. 下溢处理
- 当叶子节点删除后元素数量不足时，触发下溢处理
- 优先尝试从兄弟节点借用元素
- 如果借用失败，则进行节点合并

## 删除操作详细流程

### 1. 查找阶段
```mermaid
flowchart TD
    A[开始删除] --> B{树是否为空?}
    B -->|是| C[直接返回]
    B -->|否| D[查找叶子节点]
    D --> E[获取叶子页面]
    E --> F[在叶子节点中查找键]
```

### 2. 删除阶段
```mermaid
flowchart TD
    A[找到叶子节点] --> B{键是否存在?}
    B -->|否| C[返回删除失败]
    B -->|是| D[删除键值对]
    D --> E[标记页面为脏]
    E --> F{节点是否下溢?}
    F -->|否| G[删除完成]
    F -->|是| H[处理下溢]
```

### 3. 下溢处理
```mermaid
flowchart TD
    A[检测到下溢] --> B[尝试从左兄弟借用]
    B --> C{借用成功?}
    C -->|是| D[更新父节点键值]
    C -->|否| E[尝试从右兄弟借用]
    E --> F{借用成功?}
    F -->|是| G[更新父节点键值]
    F -->|否| H[合并节点]
    H --> I[删除被合并的页面]
    I --> J[更新父节点]
```

## 并发安全性保证

1. **原子性**: 每个删除操作要么完全成功，要么完全失败
2. **一致性**: 通过全局锁保证树结构的一致性
3. **隔离性**: 写操作之间完全隔离，不会相互干扰
4. **持久性**: 通过缓冲池管理器确保数据最终持久化到磁盘

## 性能考虑

1. **锁粒度**: 使用全局锁可能影响并发性能
2. **页面缓存**: 利用缓冲池减少磁盘I/O
3. **合并策略**: 优先借用，避免频繁的节点合并

## 注意事项

1. 删除操作可能导致树的高度减少
2. 节点合并时需要更新父节点的键值
3. 删除空页面时需要更新磁盘管理器
4. 当前实现使用粗粒度锁，可能在高并发场景下成为性能瓶颈
