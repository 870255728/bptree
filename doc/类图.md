# B+树并发数据库系统类图

## 系统架构图

```mermaid
graph TD
    subgraph 磁盘管理层
        DM[DiskManager] -- 管理 --> File[(数据库文件)]
        DM -- 读写 --> P1[Page]
    end

    subgraph 缓冲池管理层
        BPM[BufferPoolManager] -- 管理 --> P2[Page]
        BPM -- 替换策略 --> Replacer
        BPM -- 使用 --> DM
        LRUReplacer -- 实现 --> Replacer
        Guard[PageGuard] -- 封装 --> P2
        Guard -- 使用 --> BPM
    end

    subgraph B+树层
        BPT["BPlusTree<K,V,Comp>"]
        Iter["BPlusTreeIterator"]
        N["Node<K,V,Comp>"] -- 包含 --> NH["NodeHeader"]
        Leaf["LeafNode<K,V,Comp>"] -- 继承 --> N
        Internal["InternalNode<K,V,Comp>"] -- 继承 --> N
        BPT -- 使用 --> BPM
        BPT -- 包含 --> Iter
        BPT -- 管理 --> N
    end

    subgraph 并发控制层
        TXN[Transaction] -- 管理 --> BPT
        TXN -- 跟踪 --> P2
    end
```

## 详细类图

```mermaid
classDiagram

%% --- 基础设施层 ---

class DiskManager {
    - db_io_ : std::fstream
    - file_name_ : std::string
    - db_io_latch_ : std::mutex
    - next_page_id_ : page_id_t
    + DiskManager(file_name)
    + ReadPage(page_id_t, char*)
    + WritePage(page_id_t, char*)
    + AllocatePage() page_id_t
    + DeallocatePage(page_id_t)
}

class Page {
    - data_[PAGE_SIZE] : char
    - page_id_ : page_id_t
    - pin_count_ : int
    - is_dirty_ : bool
    - rlatch_ : std::shared_mutex
    - wlatch_ : std::mutex
    + GetData() char*
    + GetPageId() page_id_t
    + GetPinCount() int
    + IsDirty() bool
    + SetDirty(bool)
    + ResetMemory()
    + RLatch()
    + RUnlatch()
    + WLatch()
    + WUnlatch()
}

class PageGuard {
    - page_ : Page*
    - bpm_ : BufferPoolManager*
    - is_dirty_ : bool
    + GetData() char*
    + GetPageId() page_id_t
    + SetDirty()
    + ~PageGuard()
}

class Replacer {
    <<interface>>
    + Victim(frame_id_t*) bool
    + Pin(frame_id_t)
    + Unpin(frame_id_t)
    + Size() size_t
}

class LRUReplacer {
    - lru_list_ : std::list~frame_id_t~
    - lru_map_ : std::unordered_map~frame_id_t, iterator~
    - latch_ : std::mutex
    - capacity_ : size_t
    + Victim(frame_id_t*) bool
    + Pin(frame_id_t)
    + Unpin(frame_id_t)
    + Size() size_t
}

class BufferPoolManager {
    - pages_ : std::vector~Page*~
    - disk_manager_ : DiskManager*
    - replacer_ : Replacer*
    - free_list_ : std::list~frame_id_t~
    - page_table_ : std::unordered_map~page_id_t, frame_id_t~
    - latch_ : std::mutex
    + FetchPage(page_id_t) Page*
    + UnpinPage(page_id_t, bool)
    + FlushPage(page_id_t)
    + NewPage(page_id_t*) Page*
    + DeletePage(page_id_t)
    + FlushAllPages()
    + FetchPageGuard(page_id_t) PageGuard
    + NewPageGuard(page_id_t*) PageGuard
}

%% --- B+树核心层 ---

class NodeHeader {
    + is_leaf_ : bool
    + size_ : int
}

class Node~K_V_Comp~ {
    <<abstract>>
    + Init(char*, int)
    + Get_Size(char*) int
    + Get_Max_Size(char*) int
    + Get_Min_Size(char*) int
    + Is_Leaf(char*) bool
    + Is_Full(char*, int) bool
    + Is_Underflow(char*, int) bool
    + Set_Size(char*, int)
}

class LeafNode~K_V_Comp~ {
    + Init(char*, int)
    + Get_Next_Page_Id(char*) page_id_t
    + Set_Next_Page_Id(char*, page_id_t)
    + Keys_Ptr(char*) KeyType*
    + Values_Ptr(char*, int) ValueType*
    + Get_Value(char*, int, KeyType, ValueType*, KeyComparator) bool
    + Insert(char*, int, KeyType, ValueType, KeyComparator)
    + Remove(char*, int, KeyType, KeyComparator)
    + Split(char*, char*, int) KeyType
    + Move_Last_From(char*, char*, int)
    + Move_First_From(char*, char*, int)
    + Merge(char*, char*, int)
    + Find_Key_Index(char*, int, KeyType, KeyComparator) int
    + Value_At(char*, int, int) ValueType&
}

class InternalNode~K_V_Comp~ {
    + Init(char*, int)
    + Keys_Ptr(char*) KeyType*
    + Children_Ptr(char*, int) page_id_t*
    + Lookup(char*, int, KeyType, KeyComparator) page_id_t
    + Insert(char*, int, KeyType, page_id_t, KeyComparator)
    + Split(char*, char*, int) KeyType
    + Populate_New_Root(char*, int, KeyType, page_id_t, page_id_t)
    + Remove_At(char*, int, int)
    + Set_Key_At(char*, int, KeyType)
    + Move_Last_From(char*, char*, int, char*, int)
    + Move_First_From(char*, char*, int, char*, int)
    + Merge_Into(char*, char*, int, char*, int)
    + Find_Child_Index(char*, int, page_id_t) int
    + Child_At(char*, int, int) page_id_t
    + Move_First_Child(char*, int) page_id_t
}

class BPlusTree~K_V_Comp~ {
    - leaf_max_size_ : int
    - internal_max_size_ : int
    - comparator_ : KeyComparator
    - disk_manager_ : std::unique_ptr~DiskManager~
    - replacer_ : std::unique_ptr~Replacer~
    - bpm_ : std::unique_ptr~BufferPoolManager~
    - root_page_id_ : page_id_t
    - db_file_name_ : std::string
    - delete_db_on_destruct_ : bool
    - root_latch_ : std::shared_mutex
    + BPlusTree(db_file, leaf_max_size, internal_max_size)
    + BPlusTree(leaf_max_size, internal_max_size)
    + ~BPlusTree()
    + Is_Empty() bool
    + Insert(KeyType, ValueType, Transaction*) bool
    + Get_Value(KeyType, ValueType*, Transaction*) bool
    + Remove(KeyType, Transaction*)
    + Begin() Iterator
    + End() Iterator
    + begin() Iterator
    + end() Iterator
    + Begin(KeyType) Iterator
    + Range_Scan(KeyType, KeyType) vector~pair~
    - Start_New_Tree(KeyType, ValueType)
    - Get_Leaf_Page(KeyType, Transaction*, Operation, bool) Page*
    - Handle_Underflow(Page*, Transaction*)
    - Release_W_Latches(Transaction*)
    - Is_Safe_Page(char*, bool, bool, Operation) bool
}

class BPlusTreeIterator {
    - bpm_ : BufferPoolManager*
    - page_ : Page*
    - page_id_ : page_id_t
    - index_in_leaf_ : int
    - leaf_max_size_ : int
    + operator*() value_type
    + operator->() pointer
    + operator++() Iterator&
    + operator==(Iterator) bool
    + operator!=(Iterator) bool
    + ~BPlusTreeIterator()
}

%% --- 并发控制层 ---

class Transaction {
    - page_set_ : std::deque~Page*~
    - deleted_page_set_ : std::unordered_set~page_id_t~
    + GetPageSet() deque~Page*~&
    + AddToPageSet(Page*)
    + GetDeletedPageSet() unordered_set~page_id_t~&
    + AddToDeletedPageSet(page_id_t)
}

%% --- 关系定义 ---

Replacer <|.. LRUReplacer : 实现
BufferPoolManager o-- DiskManager : 使用
BufferPoolManager o-- Replacer : 使用
BufferPoolManager o-- Page : 管理
PageGuard o-- Page : 管理
PageGuard o-- BufferPoolManager : 使用
Node~K_V_Comp~ <|-- LeafNode~K_V_Comp~ : 继承
Node~K_V_Comp~ <|-- InternalNode~K_V_Comp~ : 继承
BPlusTree~K_V_Comp~ o-- DiskManager : 拥有
BPlusTree~K_V_Comp~ o-- Replacer : 拥有
BPlusTree~K_V_Comp~ o-- BufferPoolManager : 拥有
BPlusTree~K_V_Comp~ ..> LeafNode~K_V_Comp~ : 使用
BPlusTree~K_V_Comp~ ..> InternalNode~K_V_Comp~ : 使用
BPlusTree~K_V_Comp~ *-- BPlusTreeIterator : 包含
BPlusTree~K_V_Comp~ ..> Transaction : 使用
Transaction ..> Page : 跟踪
Transaction ..> BufferPoolManager : 管理页面生命周期
```

## 关键设计特点

### 1. 并发控制机制
- **根锁**: `std::shared_mutex root_latch_` 保护根页面ID访问
- **页面锁**: 每个Page包含读写锁(`rlatch_`, `wlatch_`)
- **两轮闩蟹**: 第一轮乐观读/叶写，第二轮悲观全路径写锁
- **事务管理**: Transaction跟踪锁定的页面和待删除页面

### 2. 内存管理
- **RAII模式**: PageGuard自动管理页面生命周期
- **引用计数**: Page的pin_count_跟踪使用情况
- **LRU替换**: 缓冲池使用LRU策略管理页面

### 3. 节点设计
- **页面视图**: Node类不拥有数据，而是解释Page的数据区
- **布局优化**: NodeHeader + Keys + Values/Children的紧凑布局
- **类型安全**: 模板化设计支持任意键值类型

### 4. 迭代器支持
- **STL兼容**: 实现标准迭代器接口
- **自动清理**: 析构时自动释放页面锁和Pin
- **范围查询**: 支持范围扫描和单键查找

### 5. 性能优化
- **时间统计**: 全局时间统计支持性能分析
- **批量操作**: 支持批量插入和删除
- **缓存友好**: 页面级缓存减少磁盘I/O