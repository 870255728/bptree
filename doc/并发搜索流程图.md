# 并发搜索流程图

## 概述
本文档描述了B+树并发搜索操作的执行流程，展示了多个线程同时进行搜索操作时的同步机制和步骤。

## 流程图

```mermaid
sequenceDiagram
    participant T1 as 线程1
    participant T2 as 线程2
    participant T3 as 线程3
    participant T4 as 线程4
    participant BPT as BPlusTree
    participant BPM as BufferPoolManager
    participant DM as DiskManager
    
    Note over T1,T4: 并发搜索操作开始
    
    par 线程1搜索操作
        T1->>BPT: Get_Value(key1, &value1, &transaction)
        Note over T1,BPT: 获取全局读锁 (std::shared_lock)
        alt 树为空
            T1-->>T1: 返回false，键不存在
        else 树不为空
            T1->>BPT: Find_Leaf_Guard(key1)
            T1->>BPM: FetchPageGuard(leaf_page_id)
            T1->>BPT: 在叶子节点查找键
            alt 找到键
                T1->>BPT: 返回对应的值
                T1-->>T1: 返回true
            else 未找到键
                T1-->>T1: 返回false
            end
        end
        Note over T1,BPT: 释放全局读锁
        T1-->>T1: 搜索操作完成
    and 线程2搜索操作
        T2->>BPT: Get_Value(key2, &value2, &transaction)
        Note over T2,BPT: 获取全局读锁 (std::shared_lock)
        T2->>BPT: Find_Leaf_Guard(key2)
        T2->>BPM: FetchPageGuard(leaf_page_id)
        T2->>BPT: 在叶子节点查找键
        Note over T2,BPT: 释放全局读锁
        T2-->>T2: 搜索操作完成
    and 线程3搜索操作
        T3->>BPT: Get_Value(key3, &value3, &transaction)
        Note over T3,BPT: 获取全局读锁 (std::shared_lock)
        T3->>BPT: Find_Leaf_Guard(key3)
        T3->>BPM: FetchPageGuard(leaf_page_id)
        T3->>BPT: 在叶子节点查找键
        Note over T3,BPT: 释放全局读锁
        T3-->>T3: 搜索操作完成
    and 线程4搜索操作
        T4->>BPT: Get_Value(key4, &value4, &transaction)
        Note over T4,BPT: 获取全局读锁 (std::shared_lock)
        T4->>BPT: Find_Leaf_Guard(key4)
        T4->>BPM: FetchPageGuard(leaf_page_id)
        T4->>BPT: 在叶子节点查找键
        Note over T4,BPT: 释放全局读锁
        T4-->>T4: 搜索操作完成
    end
    
    Note over T1,T4: 所有搜索操作完成
```

## 关键同步机制

### 1. 全局读锁
- 使用 `std::shared_mutex root_latch_` 作为全局读写锁
- 所有搜索操作都获取共享读锁 `std::shared_lock<std::shared_mutex>`
- 多个读操作可以并发执行，但写操作需要等待所有读操作完成

### 2. 页面管理
- 使用 `PageGuard` 进行自动页面管理
- 搜索操作不会修改页面内容，不需要标记为脏
- 页面在作用域结束时自动释放

### 3. 并发读优化
- 多个读操作可以同时进行，提高并发性能
- 读操作不会阻塞其他读操作
- 只有写操作会阻塞读操作

## 搜索操作详细流程

### 1. 查找阶段
```mermaid
flowchart TD
    A[开始搜索] --> B{树是否为空?}
    B -->|是| C[返回false]
    B -->|否| D[从根节点开始查找]
    D --> E[获取根页面]
    E --> F{当前节点是叶子节点?}
    F -->|否| G[在内部节点中查找子节点]
    G --> H[获取子节点页面]
    H --> F
    F -->|是| I[在叶子节点中查找键]
```

### 2. 叶子节点查找
```mermaid
flowchart TD
    A[到达叶子节点] --> B[二分查找或线性查找]
    B --> C{找到键?}
    C -->|是| D[返回对应的值]
    C -->|否| E[返回false]
    D --> F[搜索成功]
    E --> G[搜索失败]
```

### 3. 范围搜索
```mermaid
flowchart TD
    A[开始范围搜索] --> B[找到起始键的位置]
    B --> C[创建迭代器]
    C --> D[遍历到结束键]
    D --> E{是否到达结束键?}
    E -->|否| F[收集当前键值对]
    F --> G[移动到下一个键]
    G --> E
    E -->|是| H[返回结果集合]
```

## 并发安全性保证

1. **原子性**: 每个搜索操作要么完全成功，要么完全失败
2. **一致性**: 通过读锁保证读取数据的一致性
3. **隔离性**: 读操作之间可以并发执行，不会相互干扰
4. **持久性**: 搜索操作不涉及数据修改，不需要持久化

## 性能考虑

1. **读锁并发**: 多个读操作可以同时进行，提高并发性能
2. **页面缓存**: 利用缓冲池减少磁盘I/O
3. **查找优化**: 使用二分查找提高查找效率

## 读写冲突处理

```mermaid
sequenceDiagram
    participant R1 as 读线程1
    participant R2 as 读线程2
    participant W1 as 写线程1
    participant BPT as BPlusTree
    
    Note over R1,R2: 读操作并发执行
    R1->>BPT: Get_Value(key1, &value1)
    Note over R1,BPT: 获取读锁
    R2->>BPT: Get_Value(key2, &value2)
    Note over R2,BPT: 获取读锁
    
    Note over W1,BPT: 写操作等待
    W1->>BPT: Insert(key3, value3)
    Note over W1,BPT: 等待读锁释放
    
    Note over R1,BPT: 读操作完成
    R1-->>R1: 释放读锁
    R2-->>R2: 释放读锁
    
    Note over W1,BPT: 写操作开始
    Note over W1,BPT: 获取写锁
    W1-->>W1: 写操作完成
```

## 注意事项

1. 读操作不会修改树结构，因此可以安全并发
2. 写操作会阻塞所有读操作，确保数据一致性
3. 当前实现使用全局锁，可能在高并发场景下影响性能
4. 范围搜索需要遍历多个页面，可能需要更长的锁持有时间
